#DOCUMENTAÇÃO TÉCNICA DE CADA TAREFA

# Tarefa 1 – Jantar dos Filósofos com Deadlock (Java)

## Descrição Geral
Este projeto implementa uma versão básica do problema clássico do Jantar dos Filósofos, utilizando Java e threads para demonstrar explicitamente a ocorrência de deadlock em sistemas concorrentes. A estrutura do código foi intencionalmente projetada para forçar a condição de deadlock, atendendo ao objetivo proposto na tarefa.

## Estrutura do Projeto
O código foi organizado de forma modular para facilitar a leitura, manutenção e análise do comportamento concorrente:

- **Main.java** – Inicializa o sistema, cria os filósofos e garfos, controla o tempo de execução e detecta deadlock.  
- **Philosopher.java** – Representa cada filósofo como uma thread, contendo a lógica de pensar, tentar pegar garfos e comer.  
- **Fork.java** – Representa os garfos como recursos compartilhados protegidos por `synchronized`.  
- **Log.java** – Classe utilitária responsável pelo sistema de logging da aplicação.  

Essa separação foi adotada para manter o código funcional, bem estruturado e coerente com boas práticas de programação concorrente.

## Sistema de Logging
Foi implementado um sistema de logging próprio, centralizado na classe `Log`, responsável por registrar os principais eventos da execução com marcação temporal. Durante a execução, o log registra quando um filósofo inicia o estado de pensamento, quando tenta obter cada um dos garfos, quando consegue adquirir ambos os recursos e começa a se alimentar, e quando finaliza a refeição liberando os garfos. Além disso, o sistema registra explicitamente a detecção de deadlock.

Esse mecanismo de logging permite acompanhar de forma clara e cronológica o comportamento das threads, facilitando a análise do problema e a identificação do bloqueio.

## Estratégia para Forçar o Deadlock
A ocorrência de deadlock não é resultado de acaso, mas consequência direta das decisões de projeto adotadas. Todos os filósofos tentam adquirir primeiro o garfo esquerdo e mantêm esse lock enquanto tentam obter o garfo direito. Um `CyclicBarrier` é utilizado para garantir que todos iniciem a disputa pelos garfos simultaneamente, eliminando vantagens temporais entre as threads.

Após a aquisição do garfo esquerdo, é introduzido um atraso proposital, aumentando significativamente a probabilidade de que todos os filósofos estejam segurando um recurso e aguardando indefinidamente pelo próximo. Não há qualquer mecanismo de preempção, hierarquia global de locks ou política de prevenção, o que resulta em um cenário clássico de espera circular, caracterizando o deadlock.

## Detecção de Deadlock
Para identificar o problema em tempo de execução, o programa utiliza a API `ThreadMXBean`, que permite monitorar o estado das threads da JVM. Quando um deadlock é detectado, o sistema registra no log as threads envolvidas, os recursos bloqueados e a relação de posse entre os garfos. Após a identificação do deadlock, a execução é encerrada automaticamente, garantindo uma evidência clara e objetiva da ocorrência do problema.

## Evidência de Execução e Análise dos Resultados
Durante a execução do programa, observa-se que todos os filósofos conseguem adquirir o garfo esquerdo e ficam bloqueados ao tentar obter o garfo direito. Como nenhum filósofo libera o recurso já adquirido, o sistema entra em um estado de bloqueio permanente, no qual nenhuma thread consegue progredir.

Esse comportamento confirma a presença das quatro condições necessárias para o deadlock: exclusão mútua, posse e espera, não preempção e espera circular, demonstrando de forma prática e verificável o problema proposto na tarefa.

**Figura 1:** Execução do programa demonstrando a ocorrência de deadlock no problema do Jantar dos Filósofos.

---

# Tarefa 2 – Prevenção de Deadlock no Jantar dos Filósofos

## Descrição da solução
Nesta tarefa, a implementação do problema do Jantar dos Filósofos foi modificada para prevenir a ocorrência de deadlock observada na Tarefa 1. A estrutura geral do sistema foi mantida, com cinco filósofos e cinco garfos representados por objetos compartilhados, utilizando `synchronized` para garantir exclusão mútua no acesso aos garfos.

A modificação principal consiste em alterar a ordem de aquisição dos garfos para um dos filósofos. Enquanto os filósofos 1, 2, 3 e 5 tentam pegar primeiro o garfo esquerdo e depois o direito, o filósofo 4 realiza o processo inverso, pegando primeiro o garfo direito e depois o esquerdo.

Essa escolha foi feita propositalmente para quebrar a condição de espera circular, uma das quatro condições necessárias para a ocorrência de deadlock.

## Por que essa solução previne deadlock
Na Tarefa 1, todos os filósofos tentavam adquirir os recursos na mesma ordem (garfo esquerdo seguido do direito), o que permitia a formação de um ciclo de dependência circular entre as threads. Nessa situação, cada filósofo poderia segurar um garfo e aguardar indefinidamente pelo outro, caracterizando um deadlock.

Ao inverter a ordem de aquisição dos garfos para um único filósofo, a cadeia circular de espera é quebrada. Dessa forma, não é mais possível que todos os filósofos fiquem bloqueados simultaneamente esperando pelo próximo recurso, o que impede a ocorrência de deadlock.

## Possibilidade de starvation
Embora o deadlock tenha sido prevenido, ainda existe a possibilidade de starvation. Isso ocorre porque o uso de `synchronized` não garante justiça (fairness) na aquisição dos locks. Assim, um filósofo pode, em teoria, esperar por um longo período caso seus vizinhos adquiram os garfos repetidamente antes dele.

Durante o período de execução testado, no entanto, nenhum filósofo ficou sem se alimentar, indicando que a starvation não ocorreu no experimento realizado.

## Evidência de execução
O programa foi executado por aproximadamente dois minutos, conforme solicitado. Durante esse período, não foi detectada nenhuma situação de deadlock. Todos os filósofos alternaram entre os estados de pensar e comer normalmente, conforme indicado pelos logs gerados durante a execução.

Ao final da execução, o programa foi encerrado de forma controlada e as estatísticas de alimentação de cada filósofo foram exibidas.

## Estatísticas de execução
Durante o período de teste, cada filósofo conseguiu se alimentar múltiplas vezes, conforme mostrado a seguir:

- **Filósofo 1:** 23 vezes  
- **Filósofo 2:** 23 vezes  
- **Filósofo 3:** 25 vezes  
- **Filósofo 4:** 24 vezes  
- **Filósofo 5:** 22 vezes  

**Figura 2:** Execução do programa com o número de vezes que cada filósofo se alimentou.

## Comparação com a Tarefa 1
Na Tarefa 1, a implementação propositalmente permitia deadlock, o que foi confirmado pela detecção automática de threads bloqueadas em espera circular. Já na Tarefa 2, a simples alteração na ordem de aquisição dos garfos para um dos filósofos foi suficiente para eliminar essa condição, permitindo a execução contínua do sistema sem bloqueios permanentes.

Essa comparação evidencia como pequenas mudanças na estratégia de sincronização podem ter grande impacto no comportamento concorrente de um sistema.

---

# Tarefa 3 – Solução com Semáforos

## Objetivo
Implementar uma solução para o problema do Jantar dos Filósofos utilizando semáforos, com o objetivo de limitar o número de filósofos que podem tentar pegar os garfos simultaneamente e, assim, prevenir a ocorrência de deadlock.

## Descrição da solução
Nesta tarefa, foi utilizada a classe `Semaphore` do Java para controlar o acesso dos filósofos à região crítica de aquisição dos garfos. Foi criado um semáforo global com quatro permissões, considerando um cenário com cinco filósofos.

Antes de tentar pegar qualquer garfo, o filósofo deve adquirir uma permissão desse semáforo. Os garfos continuam sendo tratados como recursos exclusivos, protegidos por blocos `synchronized`, garantindo a exclusão mútua durante seu uso. Após finalizar a refeição, o filósofo libera os garfos e devolve a permissão ao semáforo, permitindo que outros filósofos avancem no processo.

## Funcionamento do algoritmo
O algoritmo segue um ciclo contínuo em que cada filósofo alterna entre os estados de pensar e comer. Ao tentar comer, o filósofo solicita uma permissão ao semáforo global. Somente após obter essa permissão ele tenta adquirir os garfos, primeiro o esquerdo e depois o direito. Caso consiga pegar ambos, o filósofo entra no estado de alimentação por um tempo aleatório. Ao término da refeição, os garfos são liberados e a permissão do semáforo é devolvida, mantendo o controle da concorrência no sistema.

## Prevenção de deadlock
O deadlock clássico do problema do Jantar dos Filósofos ocorre quando todos os filósofos conseguem pegar um garfo e ficam bloqueados aguardando indefinidamente pelo segundo, formando uma espera circular. Com a utilização do semáforo de quatro permissões, essa situação não pode ocorrer, pois não é possível que os cinco filósofos entrem simultaneamente na etapa de aquisição dos garfos.

Dessa forma, sempre haverá pelo menos um filósofo fora da disputa, permitindo que algum deles consiga adquirir ambos os garfos e prossiga com a execução, quebrando a espera circular e prevenindo o deadlock.

## Logging e evidência de execução
O sistema de logging utilizado nas tarefas anteriores foi mantido. Durante a execução, são registrados eventos como o início do pensamento, a tentativa e obtenção da permissão do semáforo, a tentativa de aquisição dos garfos, o início e o término da alimentação, bem como a liberação da permissão do semáforo.

A aplicação foi executada por aproximadamente dois minutos e, durante todo esse período, não foi observada nenhuma ocorrência de deadlock.

## Estatísticas de execução
Ao final da execução, foram coletadas estatísticas indicando quantas vezes cada filósofo conseguiu se alimentar. Os resultados mostraram uma distribuição equilibrada entre os filósofos, com valores variando entre 47 e 48 refeições por filósofo, o que indica que todos conseguiram progredir de forma semelhante durante o período analisado.

**Figura 3:** Execução do programa usando semáforos com o número de vezes que cada filósofo se alimentou.

## Comparação com a Tarefa 2
Na Tarefa 2, a prevenção de deadlock foi obtida por meio da quebra de simetria, fazendo com que um dos filósofos adquirisse os garfos em ordem diferente dos demais. Já na Tarefa 3, a prevenção ocorre através de um controle explícito da concorrência, limitando o número de filósofos que podem disputar recursos simultaneamente.

Embora essa abordagem reduza levemente o paralelismo do sistema, ela torna o comportamento mais previsível e robusto, como evidenciado pela execução contínua sem bloqueios.

## Vantagens e desvantagens da abordagem
Como vantagem, destaca-se a garantia de prevenção de deadlock por meio da limitação de concorrência, além da simplicidade conceitual da solução. Como desvantagem, observa-se a redução do paralelismo máximo e a possibilidade teórica de starvation, embora essa situação não tenha sido observada nos testes realizados.

---

# Tarefa 4 – Solução com Monitores e Garantia de Fairness

## Funcionamento da solução com monitor
Nesta tarefa, foi implementada uma solução baseada em monitores, utilizando uma classe central chamada `Mesa`, responsável por controlar de forma sincronizada o acesso aos garfos. Todos os filósofos interagem exclusivamente com essa classe para solicitar permissão para comer e para devolver os garfos após o uso.

A classe `Mesa` utiliza métodos sincronizados (`synchronized`) juntamente com os mecanismos `wait()` e `notifyAll()` para coordenar o acesso concorrente. Quando um filósofo deseja comer, ele faz uma solicitação ao monitor e é inserido em uma fila de espera, garantindo uma ordem explícita de atendimento. O filósofo só pode prosseguir quando estiver na frente da fila e quando ambos os garfos necessários estiverem disponíveis.

Essa abordagem centraliza totalmente o controle da concorrência, eliminando decisões distribuídas entre os filósofos e tornando o fluxo de sincronização mais previsível e controlado.

## Garantia de fairness
A fairness é garantida por meio do uso explícito de uma fila FIFO dentro do monitor `Mesa`. Sempre que um filósofo solicita para comer, seu identificador é inserido no final da fila. O monitor só permite que o filósofo que está na primeira posição da fila prossiga para a aquisição dos garfos.

Mesmo que os garfos estejam livres, um filósofo que não esteja na sua vez permanece bloqueado com `wait()`, aguardando notificação. Quando um filósofo termina de comer e libera os garfos, o monitor chama `notifyAll()`, permitindo que os filósofos em espera reavaliem as condições. Apenas aquele que satisfaz simultaneamente as condições de estar no início da fila e de ter os garfos disponíveis consegue prosseguir.

Esse mecanismo impede que um filósofo seja constantemente preterido por outros, assegurando que todos tenham oportunidade de comer ao longo do tempo.

## Prevenção de deadlock e starvation
O deadlock é prevenido porque nenhum filósofo adquire garfos diretamente. Toda a lógica de aquisição e liberação é centralizada no monitor, que só concede acesso quando ambos os garfos necessários estão disponíveis ao mesmo tempo. Dessa forma, não ocorre a condição de posse parcial de recursos, eliminando a possibilidade de espera circular.

A starvation também é evitada graças ao uso da fila de espera. Como os filósofos são atendidos na ordem de solicitação, não há possibilidade de um filósofo ser indefinidamente adiado. Os resultados da execução confirmam esse comportamento, uma vez que todos os filósofos apresentaram contagens de alimentação muito próximas ao final do teste.

## Comparação com as soluções anteriores
Em comparação com a Tarefa 1, onde o deadlock foi propositalmente induzido, esta solução elimina completamente a possibilidade de bloqueio permanente, além de adicionar controle explícito de fairness, inexistente na implementação inicial.

Em relação à Tarefa 2, que prevenia deadlock por meio da quebra de simetria (ordem diferente de aquisição de garfos para um filósofo), a solução com monitor é mais robusta, pois não depende de regras específicas atribuídas a um único participante. Além disso, a Tarefa 2 não garante fairness, podendo teoricamente permitir starvation.

Quando comparada à Tarefa 3, baseada em semáforos, a solução com monitor oferece maior controle e previsibilidade. Embora o semáforo limite o número de filósofos tentando comer simultaneamente, ele não impõe uma ordem explícita de atendimento. Já o monitor, ao utilizar uma fila, garante não apenas ausência de deadlock, mas também uma distribuição mais equilibrada de acesso aos recursos.

## Trade-offs entre as abordagens
A principal vantagem da abordagem com monitores é a garantia explícita de fairness, aliada à prevenção simultânea de deadlock e starvation. A centralização do controle torna o comportamento do sistema mais determinístico e mais fácil de analisar do ponto de vista teórico.

Por outro lado, essa solução introduz maior complexidade estrutural, uma vez que todo o controle de concorrência fica concentrado em uma única classe. Isso pode reduzir a escalabilidade em cenários com grande número de threads, além de aumentar o acoplamento entre os filósofos e o monitor.

Ainda assim, para fins didáticos e de demonstração de técnicas clássicas de sincronização, a solução baseada em monitores se mostra a mais completa e segura entre as implementações apresentadas.
